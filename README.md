# mq

是基于 netty 实现的 java mq 框架，主要参考主流消息队列如RocketMQ、Kafka
主要用于个人学习，理解 mq 的底层实现原理，采用了Netty框架，基于发布-订阅模型构建，支持多生产者和多消费者的应用场景。
- **发布-订阅模型**: 系统允许消息生产者向不同的主题发布消息，同时支持消费者订阅感兴趣的主题，以接收相应的消息内容。这种模型有效地实现了消息的广播和分发功能。
    
- **多队列与多消费者组**: 每个主题可以配置多个队列，且消费者组中支持多消费者。这样的设计使得系统能够处理高并发和大规模的消息流量，确保了消息处理的效率和灵活性。
    
- **多Broker部署**: 为了提高系统的可用性和扩展性，项目支持多Broker部署，分散了消息负载，增强了系统的容灾能力。
    
- **消息持久化**: 消息系统通过文件系统实现了消息的持久化存储，确保消息在系统故障时不会丢失。持久化机制采用了零拷贝技术（`mmap`），大幅提升了磁盘文件操作的性能。
    
- **负载均衡和重试机制**: 系统内置了消息发送与消费的负载均衡功能，支持多种策略（如轮询、随机、加权轮询等），以优化资源使用。与此同时，为了保证消息的可靠传递，系统还实现了消息重试机制，有效提高了消息的传递成功率。

# 主要模块

| 模块 | 说明 |
|:---|:---|
| mq-common | 公共代码 |
| mq-broker | 消息代理 |
| mq-producer | 服务端 |
| mq-consumer | 客户端 |
| mq-test | 测试模块 |

# 项目特性

可分为功能性特性（收发消息）和非功能性特性（高性能、高可用）

## 功能特性

- [x] 消息收发

- [x] 消息持久化

- [x] 普通消息
      
- [ ] 顺序消息
      
- [ ] 事务消息
      
- [ ] 延迟消息

## 非功能性特性

- [x] Broker集群

- [x] topic分区

- [x] 零拷贝和顺序写持久化

- [x] heartbeat 心跳检测机制

- [x] 消费结果ACK

- [x] 消息生产的批量发送、批量ACK

- [x] shardingKey粘性消费

- [x] 失败重试的拓展

- [x] 消费者组进度保存

- [x] fluent方式配置

- [x] 优雅关闭

- [ ] Broker多副本

- [ ] 注册中心

- [ ] 死信队列
